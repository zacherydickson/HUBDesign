#!/usr/bin/perl
use warnings;
use strict;
use File::Basename;
use Getopt::Std;
use Class::Struct;
use Bio::SeqIO;
use FindBin;
use lib File::Spec->catdir($FindBin::RealBin, '..', 'lib');
use HUBDesign::Util qw(ProcessNumericOption OpenFileHandle LoadConfig);
use HUBDesign::Logger;
use HUBDesign::BaitRegion;

############################################################
##DECLARATIONS

#structure describing info about a single gene
#tid - taxon from which the gene originates
#chr - replicon within the genome the gene exists on
#uid - unique identifier for the gene
#start,end,strand - location of the gene on the chr
#seq - the sequence of the gene
#cigar - a cigar string describing an alignment of the gene with a cluster centroid
struct  (GENE => {tid => '$', chr => '$', uid => '$', start => '$', end => '$',
                  strand => '$', seq => '$', cigar => '$', upad => '$', dpad=> '$'});

#structure describing cluster info
#uid - unique identifyer for the cluster
#members - an array of GENE objects
struct (CLUSTER => {uid => '$', members => '@'});

#structure wrapping info about clusters together
#clusters - an array of of CLUSTER objects
#gene_index - a gene id keyed hash of array ref with the first element being the cluster
#   index and the second being the gene index within the cluster
struct (CLUSTINFO => {clusters => '@', gene_index => '%'});

#structure wrapping info about bait regions together
#regions - an array of HUBDEsign::BaitRegion objects
#gene_index - a clust id keyed hash of array ref of indexes;
#   Given a cid find all relevant regions
struct (REGINFO => {regions => '@', clust_index => '%'});

my $_ID_PADDING = 5;
my %INFO_COL_NAME = (Bait => [qw(ProbeID TaxonID ClustID ClustPos)],
                     Cluster => [qw(ClusterID TaxonID GeneID CIGAR)]);
my $INFO_DELIM = "\t";
my %DEFAULT = (l => 75, p => 0, o => "context");
my %OL_BEHAVIOUR_SET = map {($_ => 1)} qw(context probe none);
my %CIGAR_MAP;
@CIGAR_MAP{qw(M I D N S H P = X)}= qw(M I D D I 0 0 M M);

sub ValidateInfoHeader($$;%);	#my %colIndex = ValidateHeader($header,$infoType,%optionalSet);
sub LoadBaitInfo();		#my @BaitList = LoadBaitInfo();
sub CollapseRegions($);    	#CollapseRegions($regInfo);
sub SimplifyCigar($);		#my $cigar = SimplifyCigar($cigar);
sub LoadClusterInfo(;%);	#my $clustInfo = LoadClustInfo(%clusterSet);
sub LoadSeqFromGFF($$);		#ProcessGFF($file,$clustInfo);
sub AdjustByCigar($$;$);	#AdjustByCigar($pos,$cigar,$bGreed);
sub GetTargetRegions($$);	#my $regInfo = GetTargetRegions($BaitInfo,$ClustInfo);
sub LogParameters();		#LogParameters();
sub ParseConfig($);		#ParseConfig($file);

############################################################
##HANDLING INPUT

my %opts;
getopts('f:l:o:p:C:vhD',\%opts);
ParseConfig($opts{C});

if(@ARGV < 2 or (@ARGV < 3 and !exists $opts{f}) or exists $opts{h}){
    my $usage = basename($0). " [-options] [-f GFF.list] ClustInfo.tsv[.gz] BaitInfo.tsv[.gz] [GFF1 ...] > BR.fna";
    if(exists $opts{h}){
        die "===Description\n".
            "\tGiven information on the baits and the clusters they were selected from\n".
            "\t\tExtracts regions of the target genomes targeted by the baits\n".
            "===Usage\n\t$usage\n".
            "===Required Inputs\n".
            "\tClustInfo.tsv\tFile generated by the Clustering phase of the pipeline\n".
            "\t\tContains info on the genes belonging to each cluster\n".
        "\t\tTab delim, w/headers: @{$INFO_COL_NAME{Cluster}}\n".
            "BaitInfo.tsv\tFile generated by the selection phase of the pipeline\n".
            "\t\tContains info on the baits, and the clusters they target\n".
            "\t\tTab delim, w/headers: @{$INFO_COL_NAME{Bait}}\n".
            "\tAt least one of the following ways of specifying Prokka annotated GFF files\n".
            "\t\t\tThese files must have fasta sequences at the end aftter a '##FASTA' line\n".
            "\t\t-f PATH\tA list file containing paths to GFF files\n".
            "\t\tGFFN\tA gff file\n".
            "\tBoth ClustInfo.tsv and BaitInfo.tsv may be gzipped, and columns may be rearranged\n".
            "===Options\n".
            "\t-l [1-∞)\tThe length of the baits [Default: $DEFAULT{l}]\n".
    "\t-o STR\tThe behaviour desired when bait regions are overlapping [Default: $DEFAULT{o}]\n".
            "\t\tcontext - Bait regions which have overlapping contexts are merged\n".
            "\t\tprobe - Regions are only merged if the probe sequences are overlapping\n".
            "\t\tnone - Overlapping regions are never merged\n".
            "\t-p [0-∞)\tThe amount of flanking context to extract [Default: $DEFAULT{p} bp]\n".
    "\t-C PATH\tPath to a HUBDesign Config file [Default: $FindBin::RealBin/../HUBDesign.cfg]\n".
            "===Flags\n".
            "\t-v\tVerbose logging output\n".
            "\t-h\tDisplay this message and exit\n";
    }
    die "Usage: $usage\n\tUse -h for more info\n";
}

foreach (keys %DEFAULT){
    $opts{$_} = exists $opts{$_} ? $opts{$_} : $DEFAULT{$_};
}

#Init Logger Verbosity
$opts{v} = exists $opts{v} ? "INFO" : "WARNING";
$opts{v} = "DEBUG" if(exists $opts{D});
my $Logger = HUBDesign::Logger->new(level => $opts{v});

my %FileDict;
@FileDict{qw(ClustInfo BaitInfo)} = map {shift @ARGV} (0 .. 1);

#Get the complete list of existing GFF files
my @GFFList = @ARGV;
if(exists $opts{f}){
    my $fh = OpenFileHandle($opts{f},"GFFList","WARNING");
    my @arr = <$fh>;
    close($fh);
    chomp(@arr);
    push(@GFFList,@arr);
}
for(my $i = 0; $i < @GFFList; $i++){
    next if(-e $GFFList[$i]);
    $Logger->Log("GFFfile ($GFFList[$i]) Does not exists: Skipping","WARNING");
    splice(@GFFList,$i--,1);
}
$Logger->Log("No GFF files provided","ERROR") unless(@GFFList);

#Check if info files exists, and check if they are gzipped
foreach my $type (keys %FileDict){
    my $file = $FileDict{$type};
    $Logger->Log("$type file ($file) doesn't exist","ERROR") unless(-e $file);
    my $cmd = ($file =~ m/\.gz$/) ? "zcat $file |" : $file;
    $FileDict{"${type}Cmd"} = $cmd;
}

#Process Simple Numeric Options
my $BaitLen = ProcessNumericOption($opts{l},$DEFAULT{l},1,undef,1,"Bait Length");
my $ContexLen = ProcessNumericOption($opts{p},$DEFAULT{p},0,undef,1,"Context Length");

#Process Overlapping behaviour
unless(exists $OL_BEHAVIOUR_SET{$opts{o}}){
    my $valid = join(", ",(sort keys %OL_BEHAVIOUR_SET));
    $valid =~ s/(.+),/$1, or/;
    $Logger->Log("Overlap behaviour must be one of $valid","ERROR");
}

LogParameters();

############################################################
##Main

my $BaitInfo = LoadBaitInfo();
$Logger->Log("No Baits loaded","ERROR") unless(@{$BaitInfo->regions});
CollapseRegions($BaitInfo) unless($opts{o} eq 'none');

my $ClustInfo = LoadClusterInfo(%{$BaitInfo->clust_index});
$Logger->Log("No Clusters loaded","ERROR") unless(@{$ClustInfo->clusters});
$Logger->Log("Loading gene sequences from gff files ...","INFO");
my $SeqCount = 0;
foreach my $file (@GFFList){
    $SeqCount += LoadSeqFromGFF($file,$ClustInfo);
}
$Logger->Log("Loaded $SeqCount gene sequences","INFO");
my $TargetInfo = GetTargetRegions($BaitInfo,$ClustInfo);
CollapseRegions($TargetInfo) if($opts{o} eq 'context' and $opts{p} > 0);
my $SeqOObj = Bio::SeqIO->newFh(-format =>'fasta');
my $NextID = 0;
$Logger->Log("Outputting Target Regions ...", "INFO");
my $RegCount = 0;
foreach my $reg (@{$TargetInfo->regions}){
    next unless(defined $reg->seq);
    my $id = sprintf("TGT_%0*d",$_ID_PADDING,$NextID++);
    my $desc = sprintf("%s | %s | %s",$reg->taxon_id, $reg->uid, $reg->clust_id);
    print $SeqOObj Bio::Seq->new(-id => $id, -desc => $desc, -seq => $reg->seq);
    $RegCount++;
}
$Logger->Log("Processing complete; Found $RegCount target regions","INFO");


############################################################
##Subroutines

#Given a BaitInfo File, loads the information about the probes
#Input - None, Uses the Gobal FileDict Variable
#Output - a REGINFO Object
sub LoadBaitInfo(){
    $Logger->Log("Loading bait info from $FileDict{BaitInfo} ...","INFO");
    my $fh = OpenFileHandle($FileDict{BaitInfoCmd},"BaitInfo");
    my %colIndex = ValidateInfoHeader(<$fh>,"Bait");
    my @idx = @colIndex{@{$INFO_COL_NAME{Bait}}};
    my @baitList;
    my %clustIndex;
    my %tSet;
    while(my $line = <$fh>){
        chomp($line);
        my @fields = split(/\t/,$line);
        my ($uid, $tid, $cid, $pos) = @fields[@idx];
        $tSet{$tid} = 1;
        my $bait = HUBDesign::BaitRegion->new(uid => $uid, taxon_id => $tid,
                                              clust_id => $cid, pos => $pos,
                                              len => $BaitLen);
        push(@baitList,$bait);
        $clustIndex{$cid} = [] unless(exists $clustIndex{$cid});
        push(@{$clustIndex{$cid}},$#baitList);
    }
    close($fh);
    my $msg = sprintf("Loaded %d baits, from %d clusters, targeting %d taxa",
                    scalar(@baitList), scalar(keys %clustIndex), scalar(keys %tSet));
    $Logger->Log($msg,"INFO");
    return REGINFO->new(regions => \@baitList, clust_index => \%clustIndex);
}

#Given a regionInfo Object, sorts the regions by txid, then clustid, then start position
# while maintaining the cluster_indexing
#Input  - a REGINFO object
#Ouptut - none, Modifies the provided object;
sub SortRegInfo($){
    my $self = shift;
    my $aref;
    #Sort the indexes of the regions so that they appear in order of txid, then clustid,
    #then position
    $aref = $self->regions;
    my @idx = sort {$aref->[$a]->taxon_id cmp $aref->[$b]->taxon_id or
                    $aref->[$a]->clust_id cmp $aref->[$b]->clust_id or
                    $aref->[$a]->pos <=> $aref->[$b]->pos} (0 .. $#{$aref});
    my %idxMap = map {($idx[$_] => $_)} (0 .. $#idx);
    #Update the order of the regions
    @{$aref} = @{$aref}[@idx];
    #Update the indexes in the clust_index
    foreach my $cid (keys %{$self->clust_index}){
        $aref = $self->clust_index($cid);
        @{$aref} = map {$idxMap{$_}} @{$aref}
    }
}

#Combines overlapping Bait Regions, reindexing as necessary
#Input - A REGINFO object;
#Output - None, modifies the provided REGINFO Object
sub CollapseRegions($){
    $Logger->Log("Collapsing overlapping regions ...","INFO");
    my $self = shift;
    SortRegInfo($self); 
    my %clustIndex = ($self->regions->[0]->clust_id => [0]);
    for(my $i = 0; $i < $#{$self->regions}; $i++){
        my $idx = $i + 1;
        my $reg1 = $self->regions($i);
        my $reg2 = $self->regions($i+1);
        #Add each region to the index
        $clustIndex{$reg2->clust_id} = [] unless(exists $clustIndex{$reg2->clust_id});
        push(@{$clustIndex{$reg2->clust_id}},$idx);
        next unless($reg1->isOverlapping($reg2));
        #If an overlap is found, remove the most recently added region from the index
        pop(@{$clustIndex{$reg2->clust_id}});
        #Replace the two adjacent, overlapping regions with on merged region
        splice(@{$self->regions},$i--,2,$reg1->merge($reg2));
    }
    #Replace the old index with the new one
    $self->clust_index(\%clustIndex);
    my $msg = sprintf("Collapsed to %d non-overlapping regions",scalar(@{$self->regions}));
    $Logger->Log($msg,"INFO");
}

#Given a cigar string, wimplifies the string to only alignment information
#   '=' and 'X' are both changed to 'M'
#   'H' and 'P' are ignored
#   'N' becomes 'D'
#   'S' becomes 'I'
#Input - a cigar string
#Output - a cigar string
sub SimplifyCigar($){
    my $cigar = shift;
    my %last = (num => undef, char => undef);
    my @chars = split("",$cigar);
    $cigar = "";
    my $char = shift(@chars);
    my $num = "";
    while(defined($char)){
        if($char =~ m/[0-9]/){ #Concatentate digits together
            $num .= $char;
            next;
        }
        $char = $CIGAR_MAP{$char};
        $char = "0" unless(defined $char);
        # 0 indicates the whole section should be ignored, eiterh H, P, or an unexpected char
        if($char ne "0"){
            if(defined $last{char} and $char eq $last{char}){
                $last{num} += $num;
            } else {
                $cigar .= $last{num}.$last{char} if(defined $last{char});
                $last{num} = $num;
                $last{char} = $char;
            }
        }
        $num = "";
    } continue{$char = shift @chars}
    $cigar .= $last{num}.$last{char};
    return $cigar;

}

#Given a clust info File, loads the informations about the clusters
#Input  - optional, a set of cluster Id, only info for these clusters will be retained
#       - uses Global variable FileDict
#Ouptut - a CLUSTINFO Object
sub LoadClusterInfo(;%){
    my %clusterSet = @_;
    $Logger->Log("Loading cluster info from $FileDict{ClustInfo} ...", "INFO");
    my $fh = OpenFileHandle($FileDict{ClustInfoCmd},"ClustInfo");
    my %colIndex = ValidateInfoHeader(<$fh>,"Cluster",(CIGAR => 1));
    my @idx = @colIndex{@{$INFO_COL_NAME{Cluster}}};
    my @clusterList;
    my %clusterIndex;
    my %geneIndex;
    my %tSet;
    while(my $line = <$fh>){
        chomp($line);
        my @fields = split(/\t/,$line);
        #If the CIGAR column is missing the corresponding index will be undefined
        #Get the mandatory values
        my ($cid, $tid, $gid) = @fields[@idx[ 0 .. ($#idx - 1)]];
        next unless(exists $clusterSet{$cid} or scalar(keys %clusterSet) == 0);
        my $gene = GENE->new(uid => $gid, tid => $tid);
        #An undefined cigar will later be assumed to be a perfect alignment
        if(defined $idx[$#idx]){
            $gene->cigar($fields[$idx[$#idx]]);
        }
        unless(exists $clusterIndex{$cid}){
            push(@clusterList,CLUSTER->new(uid => $cid));
            $clusterIndex{$cid} = $#clusterList;
        }
        push(@{$clusterList[$clusterIndex{$cid}]->members},$gene);
        $geneIndex{$gid} = [$clusterIndex{$cid},$#{$clusterList[$clusterIndex{$cid}]->members}];
        $tSet{$tid} = 1;
    }
    my $msg = sprintf("Loaded %d genes from %d clusters across %d taxa",
                    scalar(keys %geneIndex), scalar(@clusterList), scalar(keys %tSet)); 
    $Logger->Log($msg, "INFO");
    return CLUSTINFO->new(clusters => \@clusterList, gene_index => \%geneIndex);
}

#Given a position in the consensus sequence, and a cigar string for a sequence's alignment with
#   the consensus, calculate the corresponding position in the the seqeunce
#Input  - An integer
#       - a cigar string
#Output - an integer
sub AdjustByCigar($$;$){
    my ($pos, $cigar,$bGreed) = @_;
    #If a position falls inside a deletetion in the sequence, then 
    #   Should the output be the first position before the deletion or the first on after (greedy)
    $bGreed = 0 unless(defined $bGreed);
    my $oPos = $pos;
    my $cPos = 0;
    my @chars = split("",$cigar);
    my $char = shift(@chars);
    while(defined $char and $cPos < $oPos){
        my $num = $char;
        $num .= $char while(($char = shift(@chars)) =~ m/[0-9]/);
        if($char eq 'D'){
            my $val = $num;
            $val = $oPos - $cPos if($oPos - $cPos < $num);
            if($cPos + $num >= $oPos and $bGreed){
                $val = $oPos - $cPos - 1;
            }
            $pos -= $val;
        } elsif($char eq 'I'){
            $pos += $num;
        }
        $cPos += $num unless($char eq 'I');
    } continue {$char = shift(@chars)};
    return $pos;
}

#Given a set of regions corresponding to baits, and the a information about clusters
#Generates a set of regions such that each probe targeting an internal node in the
#hierarchy has a region for each leaf
#Input  - A REGINFO object
#       - A CLUSTINFO object
#Output - A REGINFO object
sub GetTargetRegions($$){
    $Logger->Log("Getting regions for each potential target ...","INFO");
    my ($baitInfo,$clustInfo) = @_;
    my @regList;
    my %clustIndex;
    foreach my $cluster (@{$clustInfo->clusters}){
        my $cid = $cluster->uid;
        my $idxRef = $baitInfo->clust_index($cid);
        next unless(defined $idxRef);
        foreach my $bait (@{$baitInfo->regions}[@{$idxRef}]){
            foreach my $gene (@{$cluster->members}){
                unless(defined $gene->seq){
                   $Logger->Log("Missing sequence for gene ".$gene->uid.": Skipping","WARNING");
                    next;
                }
                my $reg = $bait->copy();
                $reg->taxon_id($gene->tid);
                #The cigar string should with with respect to the consensus sequence
                my $cigar = $gene->cigar;
                unless(defined $cigar){
                    $Logger->Log("Missing cigar string for ".$gene->uid,"WARNING");
                    #There should be a cigar string at this point... assume a gapless alignment
                    $cigar = ($gene->end - $gene->start + 1)."M";
                }
                #Adjust the start and end positions considering the alignment to the consensus
                my $start = AdjustByCigar($reg->pos,$cigar, 0);
                my $end = AdjustByCigar($reg->pos + $reg->len -1,$cigar,1);
                next if($end - $start + 1 < $BaitLen/2); #Skip truncated probes
                #adjust the start and end positions considering the amount of padding acquired for the
                # gene
                ($start,$end) = map {$_ + $gene->upad} ($start,$end);
                #Adjust the start and end positions to get the desired level of context
                $start -= $opts{p};
                $start = 1 if($start < 1);
                $end += $opts{p};
                $end = length($gene->seq) if($end > length($gene->seq));
                my $len = $end - $start + 1;
                next if($len < $BaitLen); #Skip short regions with very littel context
                my $chrStart;
                if($gene->strand eq "-"){
                    $chrStart = $gene->end - $start + $gene->upad + 1;
                } else {
                    $chrStart = $gene->start + $start - $gene->upad;
                }
                my $uid = sprintf("%s (%d-%d)%s",$gene->chr,$chrStart,
                            $chrStart + $len - 1,$gene->strand);
                $reg->uid($uid);
                $reg->seq(substr($gene->seq,$start-1,$len));
                push(@regList,$reg);
                $clustIndex{$cid} = [] unless(exists $clustIndex{$cid});
                push(@{$clustIndex{$cid}},$#regList);
            }
        }
    }
    $Logger->Log(sprintf("Retreived %d target regions",scalar(@regList)),"INFO");
    return REGINFO->new(regions => \@regList, clust_index => \%clustIndex);
}

#Given a header line, ensures all required values are present, and returns an index of
#those columns
#Input	- a line from a file
#	- a type of info file
#	- a set[hash with values of 1] of columns which are optional
#	- uses the Global $INFO_DELIM, and %INFO_COL_NAME variables;
#Output	- a column name keyed has of array indexes 
sub ValidateInfoHeader($$;%){
    my ($line, $type, %optionalCol) = @_;
    chomp($line);
    my @headers = split(/$INFO_DELIM/,$line);
    my %colIndex = map {($headers[$_] => $_)} (0 .. $#headers);
    foreach my $col (@{$INFO_COL_NAME{$type}}){
        unless(exists $colIndex{$col} or exists $optionalCol{$col}){
            $Logger->Log("Provided ${type}Info file is missing the $col column","ERROR");
        }
    }
    return %colIndex;
}

#Given a gff file, loads relevant gene sequences
#Input  - A GFF file
#       - A clustINFO object
#Output - The number of gene sequences loaded
#       - edits the clustInfo Object
sub LoadSeqFromGFF($$){
    my ($file,$clustInfo) = @_;
    $Logger->Log("Loading sequences from $file ...", "DEBUG");
    if(-z $file){
        $Logger->Log("GFF file ($file) is empty: Skpping","WARNING");
        return 0;
    }
    my $fh = OpenFileHandle($file,"GFF");
    #Skipp initial header lines
    my $line;
    do{
        $line = <$fh>;
    } while($line =~ m/^#/);
    my %genesByChr;
    #Parse the gff entries to get the location of each gen in the sequence
    until($line =~ m/^##FASTA/){
        chomp($line);
        my ($chr, undef, undef, $s, $e, undef, $strand, undef, $info) = split(/\t/,$line);
        my %tags = split(/[=;]/,$info);
        if(exists $tags{ID}){
            my $gIDxRef = $clustInfo->gene_index($tags{ID});
            if(defined $gIDxRef){
                my $gene = $clustInfo->clusters->[$gIDxRef->[0]]->members($gIDxRef->[1]);
                $gene->chr($chr);
                $gene->start($s);
                $gene->end($e);
                $gene->strand($strand);
                $genesByChr{$chr} = [] unless(exists $genesByChr{$chr});
                push(@{$genesByChr{$chr}},$gene);
            }
        }
        $line = <$fh>;
        unless(defined($line)){
            $Logger->Log("EOF encountered before sequence information: Skipping $file","WARNING");
            return 0;
        }
    }
    #At this point only fasta formated sequences should be left in the file stream
    #We can just open it up with Bio::SeqIO
    my $IOObj = Bio::SeqIO->new(-fh => $fh, -format => 'fasta');
    my $seqCount = 0;
    while(my $seqObj = $IOObj->next_seq){
        next unless(exists $genesByChr{$seqObj->id});
        foreach my $gene (@{$genesByChr{$seqObj->id}}){
            #Extract double context around the genes to ensure there is context for probes
            my ($s,$e) = ($gene->start, $gene->end);
            my $cigar = $gene->cigar;
            unless(defined $cigar){ #Assume no CIGAR means perfect alignment
                $cigar = $e - $s + 1;
                $cigar .= "M";
            }
            my ($upad, $dpad) = ($opts{p} * 2) x 2;
            $s -= $upad;
            if($s < 1){
                $upad += $s - 1;
                $s = 1;
            }
            $e += $dpad;
            if($e > $seqObj->length){
                $dpad -= ($e - $seqObj->length);
                $e = $seqObj->length;
            }
            if($s > $e){
                my $msg = sprintf("Improper subseq indexes (%d-%d) when looking for %s in %s",$gene->start, $gene->end,$gene->uid, $seqObj->id);
                $Logger->Log($msg,"ERROR");
            }
            my $seq = $seqObj->subseq($s,$e);
            if($gene->strand eq "-"){
                $seq = Bio::Seq->new(-seq => $seq)->revcom->seq;
                ($upad, $dpad) = ($dpad, $upad);
                #Note: The cigar string doesn't need to be reversed as it is based on the properly
                #oriented sequence
            }
            $gene->seq($seq);
            $gene->upad($upad);
            $gene->dpad($dpad);
            #At this point all genes with sequences should have a cigar string
            $gene->cigar(SimplifyCigar($cigar));
            $seqCount++;
        }
    }
    $Logger->Log("\tLoaded $seqCount sequences", "DEBUG");
    return $seqCount;
}

#Setting up information for logging purposes
sub LogParameters(){
    my @paramNames = qw(ClustInfo BaitInfo GFFCount OlBehaviour Context);
    my %params;
    @params{@paramNames} = (@FileDict{qw(ClustInfo BaitInfo)}, scalar(@GFFList) , @opts{qw(o p)});
    $params{Context} .= " bp";
    $Logger->LogParameters(map {($_ => $params{$_})} @paramNames);
}

#Load any custom configuration
sub ParseConfig($){
    my $file = shift;
    $file = "$FindBin::RealBin/../HUBDesign.cfg" unless defined $file;
    unless(-e $file){
        warn "Could not find Config file ($file): Revert to Hardcoded defaults\n";
        return;
    }
    my %Config = LoadConfig($file,"WARNING");
    $_ID_PADDING = $Config{'ID-padding'} if(exists $Config{'ID-padding'});
    $DEFAULT{l} = $Config{length} if(exists $Config{length});
}
